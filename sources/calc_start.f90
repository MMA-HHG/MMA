MODULE calc_start
  USE write_start_hdf5
  ! USE write_start

  INTEGER(4) super_N,super_t
  REAL(8) numcrit,noise,noise_s,noise_t,lense_factor,chirp_factor,restartamp
  CHARACTER(15) inputfilename_t,inputfilename_c

  COMPLEX(8), ALLOCATABLE :: buffer(:)

CONTAINS

function besk0 ( x )

!*****************************************************************************80
!
!! BESK0 evaluates the Bessel K0(X) function.
!
!  Discussion:
!
!    This routine computes approximate values for the
!    modified Bessel function of the second kind of order zero
!    for arguments 0.0 < ARG <= XMAX.
!
!    See comments heading CALCK0.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    Original FORTRAN77 version by William Cody, Laura Stoltz.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, the argument of the function.
!
!    Output, real ( kind = 8 ) BESK0, the value of the function.
!
  implicit none

  real ( kind = 8 ) besk0
  integer ( kind = 4 ) jint
  real ( kind = 8 ) result
  real ( kind = 8 ) x

  jint = 1
  call calck0 ( x, result, jint )
  besk0 = result

  return
end function besk0

subroutine calck0 ( arg, result, jint )

!*****************************************************************************80
!
!! CALCK0 computes various K0 Bessel functions.
!
!  Discussion:
!
!    This routine computes modified Bessel functions of the second kind
!    and order zero, K0(X) and EXP(X)*K0(X), for real
!    arguments X.
!
!    The main computation evaluates slightly modified forms of near
!    minimax rational approximations generated by Russon and Blair,
!    Chalk River (Atomic Energy of Canada Limited) Report AECL-3461,
!    1969.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    Original FORTRAN77 version by William Cody, Laura Stoltz.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) ARG, the argument.  0 < ARG is
!    always required.  If JINT = 1, then the argument must also be
!    less than XMAX.
!
!    Output, real ( kind = 8 ) RESULT, the value of the function,
!    which depends on the input value of JINT:
!    1, RESULT = K0(x);
!    2, RESULT = exp(x) * K0(x);
!
!    Input, integer ( kind = 4 ) JINT, chooses the function to be computed.
!    1, K0(x);
!    2, exp(x) * K0(x);
!
  implicit none

  integer ( kind = 4 ) i
  integer ( kind = 4 ) jint
  real ( kind = 8 ) arg
  real ( kind = 8 ) f(4)
  real ( kind = 8 ) g(3)
  real ( kind = 8 ) p(6)
  real ( kind = 8 ) pp(10)
  real ( kind = 8 ) q(2)
  real ( kind = 8 ) qq(10)
  real ( kind = 8 ) result
  real ( kind = 8 ) sumf
  real ( kind = 8 ) sumg
  real ( kind = 8 ) sump
  real ( kind = 8 ) sumq
  real ( kind = 8 ) temp
  real ( kind = 8 ) x
  real ( kind = 8 ) xinf
  real ( kind = 8 ) xmax
  real ( kind = 8 ) xsmall
  real ( kind = 8 ) xx
!
!  Machine-dependent constants
!
  data xsmall /1.11d-16/
  data xinf /1.79d+308/
  data xmax /705.342d0/
!
!  Coefficients for XSMALL <= ARG <= 1.0
!
  data   p/ 5.8599221412826100000d-04, 1.3166052564989571850d-01, &
            1.1999463724910714109d+01, 4.6850901201934832188d+02, &
            5.9169059852270512312d+03, 2.4708152720399552679d+03/
  data   q/-2.4994418972832303646d+02, 2.1312714303849120380d+04/
  data   f/-1.6414452837299064100d+00,-2.9601657892958843866d+02, &
           -1.7733784684952985886d+04,-4.0320340761145482298d+05/
  data   g/-2.5064972445877992730d+02, 2.9865713163054025489d+04, &
           -1.6128136304458193998d+06/
!
!  Coefficients for  1.0 < ARG
!
  data  pp/ 1.1394980557384778174d+02, 3.6832589957340267940d+03, &
            3.1075408980684392399d+04, 1.0577068948034021957d+05, &
            1.7398867902565686251d+05, 1.5097646353289914539d+05, &
            7.1557062783764037541d+04, 1.8321525870183537725d+04, &
            2.3444738764199315021d+03, 1.1600249425076035558d+02/
  data  qq/ 2.0013443064949242491d+02, 4.4329628889746408858d+03, &
            3.1474655750295278825d+04, 9.7418829762268075784d+04, &
            1.5144644673520157801d+05, 1.2689839587977598727d+05, &
            5.8824616785857027752d+04, 1.4847228371802360957d+04, &
            1.8821890840982713696d+03, 9.2556599177304839811d+01/

  x = arg
!
!  0.0 < ARG <= 1.0.
!
  if ( 0.0D+00 < x ) then

    if ( x <= 1.0D+00 ) then

      temp = log ( x )

      if ( x < xsmall ) then
!
!  Return for small ARG.
!
        result = p(6) / q(2) - temp

      else

        xx = x * x

        sump = (((( &
                 p(1) &
          * xx + p(2) ) &
          * xx + p(3) ) &
          * xx + p(4) ) &
          * xx + p(5) ) &
          * xx + p(6)

        sumq = ( xx + q(1) ) * xx + q(2)
        sumf = ( ( &
                 f(1) &
          * xx + f(2) ) &
          * xx + f(3) ) &
          * xx + f(4)

        sumg = ( ( xx + g(1) ) * xx + g(2) ) * xx + g(3)

        result = sump / sumq - xx * sumf * temp / sumg - temp

        if ( jint == 2 ) then
          result = result * exp ( x )
        end if

      end if

    else if ( jint == 1 .and. xmax < x ) then
!
!  Error return for XMAX < ARG.
!
      result = 0.0D+00

    else
!
!  1.0 < ARG.
!
      xx = 1.0D+00 / x
      sump = pp(1)
      do i = 2, 10
        sump = sump * xx + pp(i)
      end do

      sumq = xx
      do i = 1, 9
        sumq = ( sumq + qq(i) ) * xx
      end do
      sumq = sumq + qq(10)
      result = sump / sumq / sqrt ( x )

      if ( jint == 1 ) then
        result = result * exp ( -x )
      end if

    end if

  else
!
!  Error return for ARG <= 0.0.
!
    result = xinf

  end if

  return
end subroutine calck0

  SUBROUTINE calc_startingfield(switch_start,p)
    IMPLICIT NONE

    INTEGER(4) switch_start,p,j,l,m
    INTEGER(8) plan_forward,plan_backward
    REAL(8) r,t,pert,pert_s,pert_t,delta_t,delta_r,tlo,norm,k_t

    CHARACTER(LEN = 3) :: ip
    CHARACTER(LEN = 10):: id

    delta_t=lt/REAL(dim_t,8) !stepwidth for t
    delta_r=lr/REAL(dim_r,8) !stepwidth for r
    tlo=-0.5D0*lt !lower bound for t
    ALLOCATE (e(dim_t,p*(dim_r/num_proc)+1:(p+1)*(dim_r/num_proc)))
    m=dim_r/num_proc
    CALL dfftw_plan_many_dft(plan_forward,1,dim_t,m,e,dim_t,1,dim_t,e,dim_t,1,dim_t,1,0)
    CALL dfftw_plan_many_dft(plan_backward,1,dim_t,m,e,dim_t,1,dim_t,e,dim_t,1,dim_t,-1,0)
    IF (p.EQ.0) THEN
       ALLOCATE(buffer(dim_t))
    ENDIF

    IF (switch_start.LE.2) THEN

       IF (p.EQ.0) THEN
          SELECT CASE (switch_start)
          CASE(1) 
             DO j=1,dim_t
                t=tlo+REAL(j,8)*delta_t
                CALL RANDOM_NUMBER(pert_t)
                buffer(j)=(1.D0+noise_t*pert_t)*exp(-t**(2*super_t))
             ENDDO
          CASE(2)
             IF (p.EQ.0) THEN
                OPEN(10,FILE=inputfilename_t,STATUS='OLD')
                DO j=1,dim_t
                   READ(10,*) buffer(j)
                ENDDO
                CLOSE(10)
                buffer=buffer/MAXVAL(ABS(buffer))
                DO j=1,dim_t
                   CALL RANDOM_NUMBER(pert_t)
                   buffer(j)=(1.D0+noise_t*pert_t)*buffer(j)
                ENDDO
             ENDIF
          END SELECT
          norm=0.D0
          DO l=1,dim_r
             r=REAL(l-1,8)*delta_r
             norm=norm+r*exp(-2.D0*r**(2*super_N))
          ENDDO
          norm=norm*2.D0*3.1415D0*delta_r
          buffer=SQRT(4.D0*3.1415D0*numcrit/norm)*buffer
       ENDIF

       DO l=p*(dim_r/num_proc)+1,(p+1)*(dim_r/num_proc)
          r=REAL(l-1,8)*delta_r
          CALL RANDOM_NUMBER(pert_s)
          DO j=1,dim_t
             t=tlo+REAL(j,8)*delta_t
             CALL RANDOM_NUMBER(pert)
             e(j,l)=buffer(j)*(1.D0+noise_s*pert_s+noise*pert)*exp(CMPLX(-r**(2*super_N),-t**2*chirp_factor+(omega_uppe-omega)*t,8))
!!! Waveguide-mode
!             e(j,l)=buffer(j)*(1.D0+noise_s*pert_s+noise*pert)*exp(CMPLX(0.D0,-t**2*chirp_factor+(omega_uppe-omega)*t,8))
!             IF (r.LE.1.D0) THEN
!                e(j,l)=e(j,l)*BESSEL_J0(2.002D0*r)
!             ELSE
!                e(j,l)=e(j,l)*besk0(SQRT(5.D0**2-2.002D0**2)*r)*BESSEL_J0(2.002D0)/besk0(SQRT(5.D0**2-2.002D0**2))
!             ENDIF
!!! Waveguide-mode         
          ENDDO
       ENDDO

    ELSE

       WRITE(ip,930) p
       DO l=1,3
          IF (ip(l:l).EQ.' ') ip(l:l)='0'
       ENDDO
       OPEN(10,FILE=inputfilename_c(1:LEN_TRIM(inputfilename_c))//'_'//ip//'.DAT',STATUS='OLD',FORM='UNFORMATTED')
       DO
          READ(10) id
          IF (id.EQ.'startfield') EXIT
       ENDDO
       DO j=p*(dim_r/num_proc)+1,(p+1)*(dim_r/num_proc)
          READ(10) e(1:dim_t,j)
       ENDDO
       CLOSE(10)

       IF (switch_start.EQ.4) THEN
          DO l=p*(dim_r/num_proc)+1,(p+1)*(dim_r/num_proc)
             DO j=1,dim_t
                t=tlo+REAL(j,8)*delta_t
                e(j,l)=ABS(e(j,l))*exp(CMPLX(0.D0,(omega_uppe-omega)*t,8))
             ENDDO
          ENDDO
       ENDIF

       e=restartamp*e

    ENDIF

    IF (switch_T.eq.1) THEN
       DO l=p*(dim_r/num_proc)+1,(p+1)*(dim_r/num_proc)
          r=REAL(l-1,8)*delta_r
          DO j=1,dim_t
             t=tlo+REAL(j,8)*delta_t
             CALL RANDOM_NUMBER(pert)
             e(j,l)=e(j,l)*exp(CMPLX(0.D0,-r**2*lense_factor,8))
          ENDDO
       ENDDO
    ELSE
       CALL dfftw_execute(plan_forward)
       e=CSHIFT(e,dim_t/2,1)
       DO l=p*(dim_r/num_proc)+1,(p+1)*(dim_r/num_proc)
          r=REAL(l-1,8)*delta_r
          DO j=1,dim_t
             k_t=8.D0*DATAN(1.D0)*REAL(j-dim_t/2-1)/lt+omega_uppe
             e(j,l)=e(j,l)*exp(CMPLX(0.D0,-r**2*k_t/omega*lense_factor,8))
          ENDDO
       ENDDO
       e=CSHIFT(e,dim_t/2,1)
       CALL dfftw_execute(plan_backward)
       e=e/REAL(dim_t,8)
    ENDIF
    CALL dfftw_destroy_plan(plan_forward)
    CALL dfftw_destroy_plan(plan_backward)
    IF (p.EQ.num_proc-1) THEN
       DEALLOCATE(buffer)
    ENDIF

930 FORMAT (I3)
    DO j=p*(dim_r/num_proc)+1,(p+1)*(dim_r/num_proc)
      e_full(1:dim_t,j) = e(1:dim_t,j)
    ENDDO
    RETURN
  END SUBROUTINE calc_startingfield

END MODULE calc_start
